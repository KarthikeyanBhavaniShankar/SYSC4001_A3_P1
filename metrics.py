import re
from collections import defaultdict

OUTPUT_FILE = "output_files/metrics_output.txt"

# -----------------------------------------------------------
# PARSE execution.txt GENERATED BY YOUR SCHEDULER
# -----------------------------------------------------------
def parse_execution(filename="execution.txt"):
    events = []

    pattern = re.compile(
        r"\|\s*(\d+)\s*\|\s*(\d+)\s*\|\s*(\w+)\s*\|\s*(\w+)\s*\|"
    )

    with open(filename, "r") as f:
        for line in f:
            match = pattern.search(line)
            if match:
                time, pid, old_s, new_s = match.groups()
                events.append((int(time), int(pid), old_s, new_s))

    return events


# -----------------------------------------------------------
# COMPUTE METRICS
# -----------------------------------------------------------
def compute_metrics(events):

    processes = defaultdict(lambda: {
        "arrival": None,
        "start": None,
        "finish": None,
        "waiting_time": 0,
        "last_ready_time": None,
        "response_time": None,
        "turnaround_time": None
    })

    all_pids = set()

    # -------------------------------------------------------
    # PROCESS EACH EVENT
    # -------------------------------------------------------
    for time, pid, old, new in events:
        all_pids.add(pid)

        # NEW → READY (arrival)
        if old == "NEW" and new == "READY":
            processes[pid]["arrival"] = time
            processes[pid]["last_ready_time"] = time

        # READY → RUNNING (start or resume)
        if new == "RUNNING":
            if processes[pid]["start"] is None:
                # FIRST time running = RESPONSE TIME
                processes[pid]["start"] = time
                processes[pid]["response_time"] = time - processes[pid]["arrival"]

            # accumulate waiting time
            if processes[pid]["last_ready_time"] is not None:
                processes[pid]["waiting_time"] += time - processes[pid]["last_ready_time"]
                processes[pid]["last_ready_time"] = None

        # RUNNING/WAITING → READY
        if new == "READY":
            processes[pid]["last_ready_time"] = time

        # RUNNING → TERMINATED
        if new == "TERMINATED":
            processes[pid]["finish"] = time

    # -------------------------------------------------------
    # WRITE RESULTS
    # -------------------------------------------------------
    with open(OUTPUT_FILE, "w") as out:

        out.write("=========== METRICS REPORT ===========\n")

        total_wait = 0
        total_turn = 0
        total_resp = 0
        count = 0

        for pid in sorted(all_pids):
            p = processes[pid]

            if p["finish"] is None:
                out.write(f"\nProcess {pid} DID NOT TERMINATE — SKIPPED\n")
                continue

            p["turnaround_time"] = p["finish"] - p["arrival"]

            total_wait += p["waiting_time"]
            total_turn += p["turnaround_time"]
            total_resp += p["response_time"]
            count += 1

            out.write(f"\nProcess {pid}:\n")
            out.write(f"  Arrival Time      : {p['arrival']}\n")
            out.write(f"  Start Time        : {p['start']}\n")
            out.write(f"  Finish Time       : {p['finish']}\n")
            out.write(f"  Waiting Time      : {p['waiting_time']}\n")
            out.write(f"  Response Time     : {p['response_time']}\n")
            out.write(f"  Turnaround Time   : {p['turnaround_time']}\n")

        if count == 0:
            out.write("\nNO completed processes — cannot compute metrics.\n")
            return

        out.write("\n=========== AVERAGES ===========\n")
        out.write(f"Average Waiting Time      : {total_wait / count:.2f}\n")
        out.write(f"Average Response Time     : {total_resp / count:.2f}\n")
        out.write(f"Average Turnaround Time   : {total_turn / count:.2f}\n")

        makespan = max(processes[pid]["finish"] for pid in all_pids if processes[pid]["finish"] is not None)
        throughput = count / makespan

        out.write(f"Throughput                : {throughput:.4f} processes per time unit\n")
        out.write("=========================================\n")

    print("\nMetrics computed → saved to:", OUTPUT_FILE)


# -----------------------------------------------------------
# MAIN
# -----------------------------------------------------------
if __name__ == "__main__":
    events = parse_execution("output_files/execution.txt")
    compute_metrics(events)
